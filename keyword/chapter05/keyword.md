## 🎯핵심 키워드

---

***1.  Domain***

- 도메인은 소프트웨어가 해결하고자 하는 문제 영역 또는 특정 비즈니스 로직을 의미한다. 즉, 애플리케이션이 집중해야 할 비즈니스 자체를 가리킨다. 
 - 도메인 주도 설계(DDD)에서 도메인은 단순히 데이터와 그 상호작용을 표현하는 것을 넘어서, 도메인이 속한 맥락과 그 안에서 수행되는 모든 행위와 규칙을 포함한 일련의 규칙과 상태를 설명하는 개념으로 발전한다.

- 도메인 객체는 데이터와 그 데이터를 처리하는 비즈니스 로직을 캡슐화한다. 
 - 예를 들어, 쇼핑몰 애플리케이션에서 '회원(Member)'과 '상품(Product)'은 각각 도메인에 해당하며, 이 각각의 도메인은 고유한 특성과 역할을 가진다. 
 - 회원 객체는 '이름', '이메일', '등급'과 같은 속성을 가지고, 상품 객체는 '가격', '재고', '카테고리' 등의 속성을 가진다. 
 - 이러한 속성들 사이의 규칙, 예를 들어, 회원 등급에 따라 할인율을 적용하는 방식, 특정 조건 하에 상품 재고를 조정하는 비즈니스 로직 등이 도메인 로직의 일환으로 포함된다.

- 이 도메인 객체는 데이터베이스의 테이블과 직접적으로 연결되기도 하지만, 데이터의 저장소와는 독립적으로 애플리케이션의 실제 로직을 담당하는 주체이다. 
 - 따라서 잘 설계된 도메인 객체는 변경이 발생해도 응집력 있고 유지보수가 쉬운 구조를 제공한다.


---


***2. 양방향 매핑***

- 양방향 매핑은 두 엔티티 간의 관계를 서로 참조할 수 있도록 설정하는 방법이다. 
 - 예를 들어, Member와 Review 엔티티 간의 관계에서, Member는 여러 개의 Review를 가지고 있을 수 있으며, 반대로 각 Review는 특정 Member에 속하게 된다. 
 - 이때, 양방향 매핑을 적용하면 Member 엔티티에서 Review를 참조하고, Review 엔티티에서도 Member를 참조할 수 있게 설정한다.

- 이 양방향 매핑을 통해 양쪽 엔티티에서 상대방 엔티티에 접근할 수 있게 됨으로써 데이터 접근성과 로직 작성의 유연성이 높아진다. 
 - 예를 들어, 회원에 대한 정보와 함께 회원이 작성한 모든 리뷰를 가져오고 싶을 때, Member 엔티티에서 reviews라는 필드를 통해 직접 접근할 수 있다. 
 - 이는 단방향 매핑에서 각각의 관계를 개별적으로 가져와서 다시 매칭해야 하는 번거로움을 줄여준다.

- 그러나 양방향 매핑은 단점도 있다. 
 - 가장 큰 문제는 순환 참조에 의해 발생하는 무한 루프와 엔티티 사이의 관계 설정이 꼬일 때 발생하는 데이터 불일치 문제다. 
   - 예를 들어, Member 엔티티의 Review 리스트에 리뷰를 추가하면, 동시에 해당 Review 엔티티의 Member 필드도 적절히 설정해 주어야 데이터의 일관성이 유지된다. 
 - 이러한 문제를 방지하기 위해 양방향 매핑에서는 보통 하나의 엔티티를 "주인"으로 지정하고, 관계의 변경을 주인 엔티티에서만 관리하도록 한다. 
  - JPA에서는 mappedBy 속성을 통해 관계의 주인을 지정하여, 반대쪽 엔티티의 데이터 업데이트에 의한 데이터 일관성 문제를 방지한다.
 

---


***3. N + 1 문제***

- N+1 문제는 JPA에서 데이터를 조회할 때 발생할 수 있는 성능 문제로, 주 엔티티를 조회하면서 연관된 엔티티도 함께 가져오려고 할 때 발생한다. 
 - 기본적으로 JPA는 지연 로딩을 통해 주 엔티티를 조회하고, 필요한 시점에 연관 엔티티를 추가로 로딩한다. 
 - 그러나 다수의 연관 엔티티를 가진 경우, N+1 문제가 발생하여 성능에 악영향을 미칠 수 있다.

- 예를 들어, Member 엔티티와 연관된 Review 엔티티를 생각해 보자. 만약 전체 회원 리스트를 조회하면서 각 회원의 리뷰도 조회하려고 한다면, 처음 회원 목록을 가져오는 쿼리 1개가 실행된다. 그러나 이후 각 회원마다 리뷰를 가져오기 위해 N개의 쿼리가 추가로 실행되므로, 총 N+1개의 쿼리가 발생하게 된다. 
 - 이는 엔티티가 많아질수록 불필요한 데이터베이스 호출이 급증하여 성능 저하를 초래한다.

- 이 문제를 해결하기 위해서는 패치 조인(Fetch Join)이나 배치 로딩(Batch Loading)을 사용할 수 있다. 
 - Fetch Join은 SQL에서 JOIN을 통해 주 엔티티와 연관 엔티티를 한 번에 가져오는 방법으로, 쿼리 호출 횟수를 줄여 N+1 문제를 방지한다. 
 - Batch Loading은 JPA에서 지정한 수만큼 데이터를 한 번에 로딩하여 쿼리 호출을 줄이는 방식으로, 연관 엔티티를 더 효율적으로 로딩할 수 있다.

- 결론적으로 N+1 문제는 엔티티 관계의 잘못된 로딩 전략으로 발생하는 성능 문제로, 이를 예방하고 해결하기 위해서는 각 로딩 전략을 잘 이해하고 필요에 맞게 조절하는 것이 중요하다.


---

