## 🎯핵심 키워드

---

***1.  Spring Data JPA의 Paging***

- Page
- Slice

- Spring Data JPA에서 Page와 Slice는 페이징된 데이터를 반환하기 위한 두 가지 주요 객체이다. 두 객체는 페이징 처리에서 다소 다른 목적과 동작 방식을 제공하며, 사용 상황에 따라 적절히 선택해야 한다.

- 페이징은 전체 데이터 중 일부만을 가져와 사용자가 원하는 정렬 방식으로 보여주는 기법이다. 이를 구현하기 위해 필요한 주요 파라미터는 다음과 같다
 - page: 원하는 페이지 번호.
 - size: 한 페이지에 포함될 데이터의 개수.
 - sort: 데이터 정렬 기준.

 Spring Data JPA에서는 PageRequest 객체를 사용하여 이러한 페이징 정보를 설정한다.

- Page와 Slice의 공통점
 - 페이징 데이터를 제공: 두 객체 모두 페이징 처리된 데이터를 포함한다.
 - Pageable 지원: PageRequest 같은 Pageable 구현체를 통해 페이징 설정을 적용할 수 있다.
 - 메서드 제공: 데이터를 순회하거나 현재 페이지 정보를 확인할 수 있는 다양한 메서드를 지원한다.

- Page와 Slice의 차이점
 - Page
  - 데이터 조회 쿼리와 함께 전체 데이터 개수를 조회하는 쿼리(count 쿼리)가 실행된다.
  - 이를 통해 전체 페이지 수와 전체 데이터 개수를 확인할 수 있다.
  - getTotalPages(): 전체 페이지 수 반환.
  - getTotalElements(): 전체 데이터 개수 반환.

 - Slice
  - 데이터 조회 쿼리만 실행된다.
  - 다음 페이지가 존재하는지만 확인하기 위해 limit(size + 1)로 데이터를 가져온다.
  - 전체 데이터 개수나 전체 페이지 수는 알 수 없다.
  - 전체 데이터 개수나 페이지 수를 반환하는 메서드는 없다.
  - 대신 hasNext()를 통해 다음 페이지가 있는지 여부만 확인 가능.


---


***2. 객체 그래프 탐색***

- 객체 A가 참조하는 객체 B, C, D 등을 객체 A를 통해 접근하는 과정을 객체 그래프 탐색이라고 한다. 이는 객체 간의 연관 관계를 탐색하는 것을 의미하며, 객체 지향 설계에서 중요한 개념이다.

- 예를 들어, 객체 A가 객체 B를 참조하고, 객체 B가 객체 C를 참조하는 경우, 객체 A에서 시작하여 객체 C에 이르기까지 탐색할 수 있다. 이러한 탐색은 객체 모델에 기반하며, 데이터베이스의 테이블 설계와 대응된다.

- SQL 기반 접근의 한계
 - SQL을 직접 사용하는 경우, 객체 그래프 탐색의 범위는 작성된 SQL 문에 의해 결정된다. 예를 들어, 특정 SQL이 객체 B와 C만 조회한다면, 객체 D에 접근하려면 추가적인 SQL이 필요하다.
 - 탐색 가능 범위를 확인하거나 확장하려면 DAO(Data Access Object)를 열어서 직접 SQL 문을 분석하고 수정해야 한다.
 - 객체 A와 관련된 모든 객체를 한 번에 조회하여 메모리에 로드하는 방식은 비효율적이다. 결국, 필요한 객체별로 여러 개의 DAO 메서드를 작성해야 한다는 단점이 있다.

- JPA와 객체 그래프 탐색
 - JPA를 사용하면 객체 그래프를 유연하게 탐색할 수 있다. 이는 JPA가 연관된 객체를 실제로 사용하는 시점에 필요한 SELECT SQL을 실행하기 때문이다. 이를 지연 로딩(Lazy Loading)이라고 하며, 데이터베이스 조회 시점을 지연시켜 효율적인 리소스 사용이 가능하다.
 - 객체 A를 사용할 때 항상 객체 B를 함께 사용하는 경우, JPA는 조인을 이용해 A를 조회할 때 B까지 즉시 함께 조회할 수 있다. 이는 연관 객체를 즉시 로딩(Eager Loading)으로 설정하여 구현할 수 있다.
 - JPA는 연관된 객체를 즉시 로딩할지, 지연 로딩할지 간단한 설정으로 정의할 수 있다. 이로 인해 객체의 사용 패턴에 따라 최적화된 데이터 조회를 제공한다.

- 객체는 동등성(Equality)과 동일성(Identity) 비교가 가능하다.
 - 동등성: 두 객체의 내용이 같은지 확인한다.
 - 동일성: 두 객체가 메모리 상에서 동일한 주소를 참조하는지 확인한다.

- 객체와 데이터베이스의 차이
 - 데이터베이스에서 동일한 행(row)을 조회하더라도, 두 번의 조회가 서로 다른 객체를 생성할 수 있다. 이는 동일성 비교에서 실패할 수 있는 원인이 된다.
 - JPA는 동일한 트랜잭션 내에서 동일한 데이터를 조회하면 같은 객체를 반환하도록 보장한다. 이를 통해 데이터베이스 행과 객체 간의 일관성을 유지할 수 있다.

- JPA는 객체 그래프 탐색을 직관적이고 유연하게 지원하며, 객체 지향 설계의 장점을 극대화한다. SQL 기반 접근의 단점을 극복하고, 객체의 사용 패턴에 맞는 데이터 조회 전략(지연 로딩과 즉시 로딩)을 통해 효율적인 애플리케이션 설계를 가능하게 한다.


---
